---
layout: default
title: Forms 
---
<p>In the HTML tutorial that you worked through on CodeAcademy, you learned about forms. Forms are the way that we send data from the client to our server, wherever our website is being hosted (or to some Javscript running on the client side). The key for dynamic websites is the ability to create a website that changes based on user input. This might seem commonplace to us know since nearly every website and webapp that we use has some degree of dynamism, it is not necessarily the only way to do things on the web. Static websites, which were the original form of websites, were basically HTML strings that were rendered by the user's browser. The user was envisioned as a consumer of that content, and getting any interaction from the user, or changing the content, or allowing the user to contribute to the site was complicated. After all, it's very easy to send strings of HTML to the user, but more complicated if you are taking input from the user. In fact, in recent years, there has been a push to consider what kinds of sites or services can be static, and what needs to be dynamic. Many websites are a combination of static and dynamic widgets, with the main page being static and various content areas being supplied by various widgets and APIs. However, at thsi point, if you want to have a website that users can contribute to in some fashion, then the website will probably be dynamic. The main way to handle user input is through forms.</p>
<h2>Forms</h2>
<p>Forms are components of HTML code that accept various inputs. For a form to work, it will have at least one input wrapped in a set of form tags. I will not go over all of the inputs possible, and there are better resources than I could provide here. Instead, I want to provide some general considerations for your forms. First, forms will have one or more input fields. These fields provide users with a way to enter data. By selecting a particular type of field, you can insist that your users provide the right kind of data. For instance, if you have a set of options in mind, it would be better to use radio buttons or a select menu than a simple text input area. This way you can pretty much guarantee that normal users will send back an expected option and unexpected options can be thrown away. Likewise, if you want a user to enter a password, providing a password input is useful because it automatically replaces entered characters with asterixes so that the user doesn't need to worry about someone seeing their password over their shoulder.</p>
<h2>Validation</h2>
<p>You can safely assume that most normal users will enter good data into your forms if you are careful about providing them with intuitive input fields. However, you cannot safely assume that most users will be normal users and not malicious looking to destroy, deface, corrupt, or otherwise access your site and server. The moment you start taking user input, you open yourself up significantly to that concern. A major concern to pay attention to in this discussion of forms is how you handle the input from malicious users. The first step is to assume that your users are going to try to send bad responses to your inputs. If at any point, your program is not carefully controlling what happens with this input, your application is at risk. It might be worth reading up on remote code execution and more importantly SQL injection. In both cases, the user is able to, instead of sending data that is passively stored away in a database, send commands that are executed and evaluated by the server.</p>
<p>The easiest way to prevent both issues is to make sure that user input is never evaluated as code. For SQL injection, this means converting all user input into literal strings that cannot disrupt the SQL statements. WTForms handles much of this for you. If you ever do find yourself writing pure SQL into your Flask app (which you can do), make sure you're escaping any special characters or even better using parameterized SQL statements. A basic SQL statement might look like this: <code class="sql">"SELECT * FROM mytable WHERE id=1;"</code> and you might want to replace 1 with the id input from your user. If you do this carelessly by just concatenating the user input into a SQL statement like so <code class="sql">SELECT * FROM mytable WHERE id=" + user_input + ";"</code>, then the user could add some extra SQL code into the input and get access to the entire table, not just the row with id=1 (if user_input is <code class="sql">1 or 1=1</code> then the statement executed would be <code class="sql">"SELECT * from mytable WHERE id=1 OR 1=1;"</code> since 1=1 is always true, all of the rows in the table will be selected). Instead, we turn the id field into a parameter in the SQL statement to be populated <strong>after</strong> the code is evaluated, like such: <code class="sql">"SELECT * FROM mytable WHERE id = @0"</code> When that code is executed, a parameter will be passed and basically fills in the @0 with whatever the string is, but read as a literal string. So the SQL server (MySQL?) will treat whatever that parameter is as a string and not as SQL code to be executed.</p>
<p>The second rule of thumb is to focus front end validation on user experience, so your front end system should guide the user to enter the right kind of data into all of the form fields. Then focus your back end on protecting your server from accepting and evaluating anything from the user. I cannot think of a case where it would be appropriate to attempt to execute code from a random user on the internet, even in a sandboxed environment. The good news for us is that our libraries take care of most of this magically, but we certainly should be aware of what's going on.</p>